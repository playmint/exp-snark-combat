// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.16;

import "forge-std/Test.sol";
// import "../src/MiMC.sol";

// [
//   {
//     constant: true,
//     inputs: [ [Object], [Object], [Object] ],
//     name: 'MiMCSponge',
//     outputs: [ [Object], [Object] ],
//     payable: false,
//     stateMutability: 'pure',
//     type: 'function'
//   }
// ]

interface ITestMiMCHasher {
    function MiMCSponge(uint256 a, uint256 b, uint256 c) external pure returns (uint256 xL, uint256 xR);
}

contract MiMCTest is Test {
    ITestMiMCHasher public hasher;

    function setUp() public {
        bytes memory args = abi.encode(/*arg1, arg2*/);
        bytes memory contractBytes = vm.envBytes("MIMC_CONTRACT_BYTES");
        bytes memory bytecode = abi.encodePacked(contractBytes, args);
        address addr;
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
        }
        hasher = ITestMiMCHasher(addr);
    }

    uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

    function multiHash(uint256[] memory arr) public view returns (uint256) {
        uint256 K = 0;
        uint256 R = 0;
        uint256 C = 0;
        for (uint i=0; i<arr.length; i++) {
            R = addmod(R, uint256(arr[i]), FIELD_SIZE);
            (R, C) = hasher.MiMCSponge(R, C, K);
        }
        return R;
    }

    function testMiMCSponge() public {
        uint256[] memory args = new uint256[](3);
        args[0] = 101;
        args[1] = 202;
        args[2] = 303;
        uint256 hash = multiHash(uint256[](args));
        assertEq(
            hash,
            // magic expected value generated by the circomlibjs mimc.multiHash func
            2125700544314979899786095756624145854401543506622061887338015583237481161222
        );
    }


}
